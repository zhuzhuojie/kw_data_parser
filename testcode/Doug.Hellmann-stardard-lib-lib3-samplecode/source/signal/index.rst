=======================================
 signal --- Asynchronous System Events
=======================================

.. module:: signal
    :synopsis: Asynchronous system events

:Purpose: Asynchronous system events

Signals are an operating system feature that provide a means of
notifying a program of an event, and having it handled asynchronously.
They can be generated by the system itself, or sent from one process
to another.  Since signals interrupt the regular flow of the program,
it is possible that some operations (especially I/O) may produce errors
if a signal is received in the middle.

Signals are identified by integers and are defined in the operating
system C headers.  Python exposes the signals appropriate for the
platform as symbols in the ``signal`` module.  The examples in this
section use ``SIGINT`` and ``SIGUSR1``.  Both are typically
defined for all Unix and Unix-like systems.

.. note::

    Programming with Unix signal handlers is a non-trivial
    endeavor. This is an introduction, and does not include all of the
    details needed to use signals successfully on every
    platform. There is some degree of standardization across versions
    of Unix, but there is also some variation, so consult the
    operating system documentation if you run into trouble.

Receiving Signals
=================

As with other forms of event-based programming, signals are received
by establishing a callback function, called a *signal handler*, that
is invoked when the signal occurs.  The arguments to the signal
handler are the signal number and the stack frame from the point in
the program that was interrupted by the signal.

.. literalinclude:: signal_signal.py
    :caption:
    :start-after: #end_pymotw_header

This example script loops indefinitely, pausing for a few seconds each
time.  When a signal comes in, the ``sleep()`` call is interrupted
and the signal handler ``receive_signal`` prints the signal number.
After the signal handler returns, the loop continues.

Send signals to the running program using ``os.kill()`` or the Unix
command line program ``kill``.

.. NOT RUNNING

.. code-block:: none

    $ python3 signal_signal.py 

    My PID is: 71387
    Waiting...
    Waiting...
    Waiting...
    Received: 30
    Waiting...
    Waiting...
    Received: 31
    Waiting...
    Waiting...
    Traceback (most recent call last):
      File "signal_signal.py", line 28, in <module>
        time.sleep(3)
    KeyboardInterrupt

The previous output was produced by running ``signal_signal.py`` in
one window, then in another window running:

.. NOT RUNNING

.. code-block:: none

    $ kill -USR1 $pid
    $ kill -USR2 $pid
    $ kill -INT $pid


Retrieving Registered Handlers
==============================

To see what signal handlers are registered for a signal, use
``getsignal()``.  Pass the signal number as argument.  The return
value is the registered handler, or one of the special values
``SIG_IGN`` (if the signal is being ignored), ``SIG_DFL``
(if the default behavior is being used), or ``None`` (if the existing
signal handler was registered from C, rather than Python).

.. literalinclude:: signal_getsignal.py
    :caption:
    :start-after: #end_pymotw_header

Again, since each OS may have different signals defined, the output on
other systems may vary.  This is from OS X:

.. {{{cog
.. cog.out(run_script(cog.inFile, 'signal_getsignal.py'))
.. }}}

.. code-block:: none

	$ python3 signal_getsignal.py
	
	SIGHUP     ( 1): SIG_DFL
	SIGINT     ( 2): <built-in function default_int_handler>
	SIGQUIT    ( 3): SIG_DFL
	SIGILL     ( 4): SIG_DFL
	SIGTRAP    ( 5): SIG_DFL
	SIGIOT     ( 6): SIG_DFL
	SIGEMT     ( 7): SIG_DFL
	SIGFPE     ( 8): SIG_DFL
	SIGKILL    ( 9): None
	SIGBUS     (10): SIG_DFL
	SIGSEGV    (11): SIG_DFL
	SIGSYS     (12): SIG_DFL
	SIGPIPE    (13): SIG_IGN
	SIGALRM    (14): <function alarm_received at 0x1019a6a60>
	SIGTERM    (15): SIG_DFL
	SIGURG     (16): SIG_DFL
	SIGSTOP    (17): None
	SIGTSTP    (18): SIG_DFL
	SIGCONT    (19): SIG_DFL
	SIGCHLD    (20): SIG_DFL
	SIGTTIN    (21): SIG_DFL
	SIGTTOU    (22): SIG_DFL
	SIGIO      (23): SIG_DFL
	SIGXCPU    (24): SIG_DFL
	SIGXFSZ    (25): SIG_IGN
	SIGVTALRM  (26): SIG_DFL
	SIGPROF    (27): SIG_DFL
	SIGWINCH   (28): SIG_DFL
	SIGINFO    (29): SIG_DFL
	SIGUSR1    (30): SIG_DFL
	SIGUSR2    (31): SIG_DFL

.. {{{end}}}


Sending Signals
===============

The function for sending signals from within Python is
``os.kill()``.  Its use is covered in the section on the :mod:`os`
module, :ref:`creating-processes-with-os-fork`.

Alarms
======

Alarms are a special sort of signal, where the program asks the OS to
notify it after some period of time has elapsed.  As the standard
module documentation for :mod:`os` points out, this is useful for avoiding
blocking indefinitely on an I/O operation or other system call.

.. literalinclude:: signal_alarm.py
    :caption:
    :start-after: #end_pymotw_header

In this example, the call to ``sleep()`` is interrupted, but then
continues after the signal is processed so the message printed after
``sleep()`` returns shows that the program was paused for at least
as long as the sleep duration.

.. {{{cog
.. cog.out(run_script(cog.inFile, 'signal_alarm.py'))
.. }}}

.. code-block:: none

	$ python3 signal_alarm.py
	
	Before: Sat Apr 22 14:48:57 2017
	Alarm : Sat Apr 22 14:48:59 2017
	After : Sat Apr 22 14:49:01 2017

.. {{{end}}}


Ignoring Signals
================

To ignore a signal, register ``SIG_IGN`` as the handler.  This
script replaces the default handler for ``SIGINT`` with
``SIG_IGN``, and registers a handler for ``SIGUSR1``.  Then
it uses ``signal.pause()`` to wait for a signal to be received.

.. literalinclude:: signal_ignore.py
    :caption:
    :start-after: #end_pymotw_header

Normally ``SIGINT`` (the signal sent by the shell to a program
when the user presses ``Ctrl-C``) raises a ``KeyboardInterrupt``.
This example ignores ``SIGINT`` and raises ``SystemExit``
when it sees ``SIGUSR1``.  Each ``^C`` in the output represents
an attempt to use ``Ctrl-C`` to kill the script from the terminal.
Using ``kill -USR1 72598`` from another terminal eventually causes the
script to exit.

.. NOT RUNNING

.. code-block:: none

    $ python3 signal_ignore.py 

    My PID: 72598
    ^C^C^C^CExiting


Signals and Threads
===================

Signals and threads do not generally mix well because only the main
thread of a process will receive signals.  The following example sets
up a signal handler, waits for the signal in one thread, and sends the
signal from another.

.. literalinclude:: signal_threads.py
    :caption:
    :start-after: #end_pymotw_header

The signal handlers were all registered in the main thread because
this is a requirement of the ``signal`` module implementation for
Python, regardless of underlying platform support for mixing threads
and signals.  Although the receiver thread calls ``signal.pause()``,
it does not receive the signal.  The ``signal.alarm(2)`` call near the
end of the example prevents an infinite block, since the receiver
thread will never exit.

.. NOT RUNNING

.. code-block:: none

    $ python3 signal_threads.py
    
    Waiting for signal in receiver
    Sending signal in sender
    Received signal 30 in MainThread
    Waiting for receiver
    Alarm clock

Although alarms can be set in any thread, they are always received by
the main thread.

.. literalinclude:: signal_threads_alarm.py
    :caption:
    :start-after: #end_pymotw_header

The alarm does not abort the ``sleep()`` call in
``use_alarm()``.

.. {{{cog
.. cog.out(run_script(cog.inFile, 'signal_threads_alarm.py', ignore_error=True))
.. }}}

.. code-block:: none

	$ python3 signal_threads_alarm.py
	
	Sat Apr 22 14:49:01 2017 Setting alarm in alarm_thread
	Sat Apr 22 14:49:01 2017 Sleeping in alarm_thread
	Sat Apr 22 14:49:01 2017 Waiting for alarm_thread
	Sat Apr 22 14:49:02 2017 Alarm in MainThread
	Sat Apr 22 14:49:04 2017 Done with sleep in alarm_thread
	Sat Apr 22 14:49:04 2017 Exiting normally

.. {{{end}}}

.. seealso::

   * :pydoc:`signal`

   * :pep:`475` -- Retry system calls failing with EINTR

   * :mod:`subprocess` -- More examples of sending signals to
     processes.

   * :ref:`creating-processes-with-os-fork` -- The ``kill()``
     function can be used to send signals between processes.
