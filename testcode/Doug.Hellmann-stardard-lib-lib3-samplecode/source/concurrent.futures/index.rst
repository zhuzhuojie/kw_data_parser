=========================================================
 concurrent.futures --- Manage Pools of Concurrent Tasks
=========================================================

.. module:: concurrent.futures
   :synopsis: Managing Pools of Concurrent Tasks

:Purpose: Easily manage tasks running concurrently and in parallel.

The ``concurrent.futures`` modules provides interfaces for running
tasks using pools of thread or process workers. The APIs are the same,
so applications can switch between threads and processes with minimal
changes.

The module provides two types of classes for interacting with the
pools. *Executors* are used for managing pools of workers, and
*futures* are used for managing results computed by the workers. To
use a pool of workers, an application creates an instance of the
appropriate executor class and then submits tasks for it to run. When
each task is started, a ``Future`` instance is returned. When the
result of the task is needed, an application can use the
``Future`` to block until the result is available. Various APIs
are provided to make it convenient to wait for tasks to complete, so
that the ``Future`` objects do not need to be managed directly.

Using map() with a Basic Thread Pool
====================================

The ``ThreadPoolExecutor`` manages a set of worker threads,
passing tasks to them as they become available for more work. This
example uses ``map()`` to concurrently produce a set of results from
an input iterable.  The task uses ``time.sleep()`` to pause a
different amount of time to demonstrate that, regardless of the order
of execution of concurrent tasks, ``map()`` always returns the
values in order based on the inputs.

.. literalinclude:: futures_thread_pool_map.py
   :caption:
   :start-after: #end_pymotw_header

The return value from ``map()`` is actually a special type of
iterator that knows to wait for each response as the main program
iterates over it.

.. {{{cog
.. cog.out(run_script(cog.inFile, 'futures_thread_pool_map.py', line_break_mode='wrap'))
.. }}}

.. code-block:: none

	$ python3 futures_thread_pool_map.py
	
	main: starting
	ThreadPoolExecutor-0_0: sleeping 5
	ThreadPoolExecutor-0_1: sleeping 4
	main: unprocessed results <generator object
	Executor.map.<locals>.result_iterator at 0x103e12780>
	main: waiting for real results
	ThreadPoolExecutor-0_1: done with 4
	ThreadPoolExecutor-0_1: sleeping 3
	ThreadPoolExecutor-0_0: done with 5
	ThreadPoolExecutor-0_0: sleeping 2
	ThreadPoolExecutor-0_0: done with 2
	ThreadPoolExecutor-0_0: sleeping 1
	ThreadPoolExecutor-0_1: done with 3
	ThreadPoolExecutor-0_0: done with 1
	main: results: [0.5, 0.4, 0.3, 0.2, 0.1]

.. {{{end}}}

Scheduling Individual Tasks
===========================

In addition to using ``map()``, it is possible to schedule an
individual task with an executor using ``submit()``, and use the
``Future`` instance returned to wait for that task's results.

.. literalinclude:: futures_thread_pool_submit.py
   :caption:
   :start-after: #end_pymotw_header

The status of the future changes after the tasks is completed and the
result is made available.

.. {{{cog
.. cog.out(run_script(cog.inFile, 'futures_thread_pool_submit.py'))
.. }}}

.. code-block:: none

	$ python3 futures_thread_pool_submit.py
	
	main: starting
	ThreadPoolExecutor-0_0: sleeping 5
	main: future: <Future at 0x1034e1ef0 state=running>
	main: waiting for results
	ThreadPoolExecutor-0_0: done with 5
	main: result: 0.5
	main: future after result: <Future at 0x1034e1ef0 state=finished
	 returned float>

.. {{{end}}}

Waiting for Tasks in Any Order
==============================

Invoking the ``result()`` method of a ``Future`` blocks until
the task completes (either by returning a value or raising an
exception), or is canceled. The results of multiple tasks can be
accessed in the order the tasks were scheduled using ``map()``. If
it does not matter what order the results should be processed, use
``as_completed()`` to process them as each task finishes.

.. literalinclude:: futures_as_completed.py
   :caption:
   :start-after: #end_pymotw_header

Because the pool has as many workers as tasks, all of the tasks can be
started. They finish in a random order so the values generated by
``as_completed()`` are different each time the example runs.

.. {{{cog
.. cog.out(run_script(cog.inFile, 'futures_as_completed.py'))
.. }}}

.. code-block:: none

	$ python3 futures_as_completed.py
	
	main: starting
	main: result: (1, 0.1)
	main: result: (5, 0.5)
	main: result: (3, 0.3)
	main: result: (2, 0.2)
	main: result: (4, 0.4)

.. {{{end}}}

Future Callbacks
================

To take some action when a task completed, without explicitly waiting
for the result, use ``add_done_callback()`` to specify a new
function to call when the ``Future`` is done. The callback should
be a callable taking a single argument, the ``Future`` instance.

.. literalinclude:: futures_future_callback.py
   :caption:
   :start-after: #end_pymotw_header

The callback is invoked regardless of the reason the ``Future``
is considered "done," so it is necessary to check the status of the
object passed in to the callback before using it in any way.

.. {{{cog
.. cog.out(run_script(cog.inFile, 'futures_future_callback.py', line_break_mode='wrap'))
.. }}}

.. code-block:: none

	$ python3 futures_future_callback.py
	
	main: starting
	5: sleeping
	5: done
	5: value returned: 0.5

.. {{{end}}}

Canceling Tasks
===============

A ``Future`` can be canceled, if it has been submitted but not
started, by calling its ``cancel()`` method.

.. literalinclude:: futures_future_callback_cancel.py
   :caption:
   :start-after: #end_pymotw_header

``cancel()`` returns a Boolean indicating whether or not the task
was able to be canceled.

.. {{{cog
.. cog.out(run_script(cog.inFile, 'futures_future_callback_cancel.py'))
.. }}}

.. code-block:: none

	$ python3 futures_future_callback_cancel.py
	
	main: starting
	main: submitting 10
	10: sleeping
	main: submitting 9
	9: sleeping
	main: submitting 8
	main: submitting 7
	main: submitting 6
	main: submitting 5
	main: submitting 4
	main: submitting 3
	main: submitting 2
	main: submitting 1
	1: canceled
	2: canceled
	3: canceled
	4: canceled
	5: canceled
	6: canceled
	7: canceled
	8: canceled
	main: did not cancel 9
	main: did not cancel 10
	10: done
	10: not canceled
	9: done
	9: not canceled

.. {{{end}}}

Exceptions in Tasks
===================

If a task raises an unhandled exception, it is saved to the
``Future`` for the task and made available through the
``result()`` or ``exception()`` methods.

.. literalinclude:: futures_future_exception.py
   :caption:
   :start-after: #end_pymotw_header

If ``result()`` is called after an unhandled exception is raised
within a task function, the same exception is re-raised in the current
context.

.. {{{cog
.. cog.out(run_script(cog.inFile, 'futures_future_exception.py'))
.. }}}

.. code-block:: none

	$ python3 futures_future_exception.py
	
	main: starting
	5: starting
	main: error: the value 5 is no good
	main: saw error "the value 5 is no good" when accessing result

.. {{{end}}}

Context Manager
===============

Executors work as context managers, running tasks concurrently and
waiting for them all to complete. When the context manager exits, the
``shutdown()`` method of the executor is called.

.. literalinclude:: futures_context_manager.py
   :caption:
   :start-after: #end_pymotw_header

This mode of using the executor is useful when the thread or process
resources should be cleaned up when execution leaves the current
scope.

.. {{{cog
.. cog.out(run_script(cog.inFile, 'futures_context_manager.py'))
.. }}}

.. code-block:: none

	$ python3 futures_context_manager.py
	
	main: starting
	1
	2
	3
	4
	main: done

.. {{{end}}}

Process Pools
=============

The ``ProcessPoolExecutor`` works in the same way as
``ThreadPoolExecutor``, but uses processes instead of
threads. This allows CPU-intensive operations to use a separate CPU
and not be blocked by the CPython interpreter's global interpreter
lock.

.. literalinclude:: futures_process_pool_map.py
   :caption:
   :start-after: #end_pymotw_header

As with the thread pool, individual worker processes are reused for
multiple tasks.

.. {{{cog
.. cog.out(run_script(cog.inFile, 'futures_process_pool_map.py'))
.. }}}

.. code-block:: none

	$ python3 futures_process_pool_map.py
	
	ran task 5 in process 40854
	ran task 4 in process 40854
	ran task 3 in process 40854
	ran task 2 in process 40854
	ran task 1 in process 40854

.. {{{end}}}

If something happens to one of the worker processes to cause it to
exit unexpectedly, the ``ProcessPoolExecutor`` is considered
"broken" and will no longer schedule tasks.

.. literalinclude:: futures_process_pool_broken.py
   :caption:
   :start-after: #end_pymotw_header

The ``BrokenProcessPool`` exception is actually thrown when the
results are processed, rather than when the new task is submitted.

.. {{{cog
.. cog.out(run_script(cog.inFile, 'futures_process_pool_broken.py', line_break_mode='wrap'))
.. }}}

.. code-block:: none

	$ python3 futures_process_pool_broken.py
	
	getting the pid for one worker
	killing process 40858
	submitting another task
	could not start new tasks: A process in the process pool was
	terminated abruptly while the future was running or pending.

.. {{{end}}}



.. seealso::

   * :pydoc:`concurrent.futures`

   * :pep:`3148` -- The proposal for creating the
     ``concurrent.futures`` feature set.

   * :ref:`asyncio-executors`

   * :mod:`threading`

   * :mod:`multiprocessing`
